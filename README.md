[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-22041afd0340ce965d47ae6ef1cefeee28c7c493a6346c4f15d667ab976d596c.svg)](https://classroom.github.com/a/kdfTwECC)

# Midterm p1: Report on Analysis of Fibonacci Series

- **Author**: Zhanyi Chen
- **GitHub Repo**: [[linke to github repo with this report](https://github.com/CS5008Fall2025/midterm-report-Ashx-xhsA)]
- **Semester**:25Spring
- **Languages Used**: c, python

## Overview

This report focuses on the speed differences between implementations of Fibonacci Series<sup>[1]</sup>

The **Fibonacci sequence** is a sequence in which each element is the sum of the two elements that precede it. Numbers that are part of the Fibonacci sequence are known as **Fibonacci numbers**, commonly denoted $F_n$â€Š. Many writers begin the sequence with 0 and 1, although some authors start it from 1 and 1 and some (as did Fibonacci) from 1 and 2. Starting from 0 and 1, the sequence begins:

$$0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ... $$

The Fibonacci numbers may be defined by the recurrence relation<sup>[1]</sup> :

```math
 F_0 = 1, F_1 = 1\\ 

and\\

 F_n = F_{n - 1} + F_{n-2} \

( for \ n > 1)
```

There are multiple ways to implement Pascal's Triangle with code, each discussed in more detail below. However,
for the implementations I used in this report the following chart represents the Big O value.

| Version             | Big O    | Space Used       |
| :------------------ | :------- | :--------------- |
| Iterative           | $O(n^2)$ | $O(n^2)$         |
| Recursive           | $O(2^n)$ | $O(n)$ or $O(1)$ |
| Dynamic Programming | $O(n^2)$ | $O(n^2)$         |

## Empirical Data & Discussion

## Language Analysis

### Language 1: C

### Language 2:Python

### Comparison and Discussion Between Experiences

## Conclusions / Reflection

## References
